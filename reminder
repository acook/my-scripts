#!/usr/bin/ruby
# Create and display reminders

class Reminder
  require 'yaml'

  attr_accessor :name, :text, :reminder_file

  @default_reminder_file = "#{`echo -ne $HOME`}/.reminder"

  def initialize(attributes = nil)
    @name = attributes[:name]
    @text = attributes[:text]
    @reminder_file = attributes[:reminder_file]

    result = yield self if block_given?
    result
  end

  def reminder_file
    @reminder_file || @default_reminder_file
  end

  def save(file = reminder_file)
    self.class.raw_append self.hashify
  end

  def destroy
    self.class.destroy hash
  end

  def self.load(file = reminder_file)
    all_reminders = self.raw_load file
    all_reminders.dehashify
  end

  # find a saved reminder and destroy it
  def self.destroy(reminders_to_destroy, file = reminder_file)
    # load up existing reminders
    loaded_reminders = self.raw_load file

    if reminders_to_destroy.is_a? Array
      array_of_reminder_hashes = reminders_to_destroy.map{|r|r.is_a? Reminder ? r.hash : r.to_i}
    else # wrap it in an array
      reminders_to_destroy = [reminders_to_destroy] 
    end
   
    resulting_reminders = loaded_reminders.reject{|h, d| array_of_reminder_hashess.includes h}
    
    # if we found a reminder to delete then save the result in the reminder file
    # and return the new set of reminders from the file
    unless loaded_reminders == resulting_reminders
      return self.raw_clear_and_write resulting_reminders.hashify, file
    else # if we didn't, then return nil
      return nil
    end
  end

  def data
    { :name => name,
      :text => text
    }
  end

  def to_yaml
    hashify.to_yaml
  end

  def hash
    data.hash
  end

  def hashify
    {hash => data}
  end

  private 

  # turns an array of reminders into a hashed hash of reminders
  def self.hashify(array_of_reminders)
    # @rs = Hash.new; return array_of_reminders.each{|r| @rs.merge r.hashify}
    array_of_reminders.inject(Hash.new){|rs, r| rs.merge r.hashify}
  end

  # we don't actually want the hash, just the data
  # then we pass the resulting array to the contructor
  # so we get real Reminder objects returned
  def self.dehashify(hash_of_reminders)
    all_reminders.map{|hash, data| self.new data}
  end

  # abstract the reminder loading so I can change the format easily down the road
  # should return a hash of the data from the file, we don't care how it gets that hash though
  # TODO: implement format options as needed
  def self.raw_load(file, format = :yaml)
    YAML.load_file file
  end

  # accepts a hash (using hashify) of Reminders
  # appends reminders to the end of the file
  def self.raw_append(reminders, file, format = :yaml)
    File.new(file, 'a') do |r_file|
      r_file.puts reminders.to_yaml
    end
  end

  # accepts a hash (using hashify) of Reminders
  # clears the file and saves a fresh one in its place
  def self.raw_clear_and_write(reminders, file, format = :yaml)
    File.new(file, 'w') do |r_file|
      r_file.puts reminders.to_yaml
    end
  end

end

# Grab the name of the command we're running (if you have a weird commandline, this might return weird results).
command = $0.split('/').last

# If any of the arguments request help (or the user hasn't passed in any arguments) then exit with usage.
exit puts("#{command} - Reminder utility, stores, retrieves, and deletes reminders\nUsage: #{command} [OPTIONS] \"NAME OF REMINDER\" TEXT OF REMINDER..").to_i if ARGV.empty? || !(ARGV & %w{-h -? --help}).empty?

# Are we trying to delete a reminder? 
if ARGV.delete '-d' 
  exit puts("Reminder \"\" #{Reminder.destroy(ARGV[0]) ? "deleted." : "was not found."}")
end

# TODO: add support for alternate reminder files
# if ARGV.delete '-f' .... end

# or maybe we want a list of reminders
if ARGV.delete '-l'
  exit Reminder.load.each{|r| puts r}
end

# but usually we just want to add a reminder
exit puts("New reminder #{Reminder.new :name => ARGV.shift, :text => ARGV.join(' ') ? 'added.' : 'could not be added!'}")

