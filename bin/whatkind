#!/usr/bin/env ruby

require 'pathname'

class WhatKind
  class Walker
    def initialize paths
      @paths = paths
    end

    def walk recourse = 0
      @paths.each do |path|
        Formatter.new(wrap path).render recourse
      end
    end

    def wrap path
      path = Pathname.new path
      if path.directory? then
        Directory.new path
      else
        Entry.new path
      end
    end
  end

  class Entry
    def initialize path
      @path = Pathname.new path
    end
    attr :path

    def type
      @type ||= %x[file #{@path}].gsub(/^#{@path}:\s+/, '').strip
    end

    def children
      nil
    end

    def directory?
      self.class == Directory
    end

    def name
      @path.basename.to_s
    end
  end

  class Directory < Entry
    def initialize path
      super path
    end

    def children
      @children ||= path.children.map do |child|
        if child.directory? then
          Directory.new child
        else
          Entry.new child
        end
      end
    end

    def longest
      @longest ||= children.max{|c| c.name.length }.name.length
    end
  end

  class Theme
    def colors
      @colors ||= {
        /bash|Bourne/      => fg(:green),
        /zsh/              => fg(:blue),
        /shell|SHELL/      => fg(:purple),
        /perl/             => fg(:yellow),
        /ruby/             => fg(:red),
        /python/           => fg(:cyan),
        /x86|i386/         => fgb(:blue),
        /broken|NOT FOUND/ => fgb(:red),
        /link|socket/      => fgb(:yellow),
        /directory/        => fgb(:black),
        /program/          => fgb(:yellow),
        /GIF/              => fgb(:purple),
      }
    end

    COLOR_MAP = {
      black:  0,
      red:    1,
      green:  2,
      yellow: 3,
      blue:   4,
      purple: 5,
      cyan:   6,
      white:  7,
    }

    def initialize entry
      @entry = entry
    end

    def color
      colors.detect do |regex, ansi|
        break ansi if regex =~ @entry.type
      end || "\033[0m"
    end

    def fg color_name
      esc 0, "3#{COLOR_MAP[color_name]}"
    end

    def fgb color_name
      esc 1, "3#{COLOR_MAP[color_name]}"
    end

    def esc style, color_code
      "\033[#{style};#{color_code}m"
    end
  end

  class Formatter
    def initialize root
      @root = root
    end

    def render recourse = 0
      render_recourse @root, recourse
    end

    def render_recourse entry, recourse, indent = 0, parent_longest = 0
      if entry.directory? then
        if entry.children.empty? then
          line entry, indent, entry.longest
        else
          line entry, indent, parent_longest
          entry.children.each do |child|
            render_recourse child, (recourse - 1), (indent + 1), (entry.longest + 1)
          end
        end
      else
        line entry, indent, parent_longest
      end
    end

    def line entry, indent, longest
      print Theme.new(entry).color, (' ' * (indent * 2)),
        entry.name.ljust(longest), ?\t, entry.type, ?\n
    end
  end

  class CLI
    def initialize args
      @recourse = args.include?('-r') ? Float::INFINITY : 0
      @paths = args.reject{|a| a == '-r' }
    end

    def recourse?
      @recourse
    end

    def run
      walker.walk @recourse
    end

    def walker
      if @paths.empty? then
        Walker.new [Pathname.pwd]
      else
        Walker.new @paths
      end
    end
  end

end

WhatKind::CLI.new(ARGV).run

exit 0

def self.dir_types dir, recourse = 0
  longest = 0
  results = Array.new
  path = Pathname.new dir

  if path.directory? && recourse > -1 then
    path.children.each do |subpath|
      if subpath.directory? && recourse > 0 then
        dir_info = dir_types(subpath, -1)

        dir_info = dir_info.first.first
        dir_info[0] = "SUBPATH: #{dir_info.first.to_s}"

        results << dir_info
        r, l    = dir_types subpath, recourse - 1
        longest = [l, longest].max
        results.concat r
      else
        longest = [subpath.basename.to_s.length, longest].max
        type    = %x[file #{subpath}].gsub(/#{subpath}:\s/, '')

        results << [subpath.basename, type]
      end
    end
  elsif path.exist? then
    type    = %x[file #{path}].gsub(/^#{path}:\s/, '')
    results << [path.basename, type]
  else
    results << [path.basename, "PATH NOT FOUND"]
  end

  [results, longest]
end

recourse = ARGV.detect{|a| a == '-r' } ? Float::INFINITY : 0
ARGV.reject!{|a| a == '-r' } if recourse

if ARGV.empty? then
  results, longest = dir_types Pathname.pwd, recourse
else
  longest = 0
  results = ARGV.each_with_object Array.new do |dir, list|
    r, l = dir_types dir, recourse
    longest = [l, longest].max
    list.concat r
  end
end

print "\033[1m  NAME".ljust(longest), "\t  TYPE\n"
results.each do |name, type|
  color = colors.detect{|r,c| break c if r =~ type } || "\033[0m"
  print color, name.to_s.ljust(longest), "\t", type
end

