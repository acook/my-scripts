#!/usr/bin/env ruby

require 'pathname'

class WhatKind

  class Entry
    def initialize path
      @path = Pathname.new path
    end
    attr :path

    def type
      @type ||= %x[file #{@path}].gsub(/^#{@path}:\s+/, '').strip
    end

    def children
      nil
    end

    def directory?
      self.class == Directory
    end

    def name
      @path.basename.to_s
    end
  end

  class Directory < Entry
    def children
      @children ||= path.children.map do |child|
        if child.directory? then
          Directory.new child
        else
          Entry.new child
        end
      end
    end

    def longest
      @longest ||= children.map{|c| c.name.length }.max
    end
  end

  class Theme
    def colors
      @colors ||= {
        /bash|Bourne/      => fg(:green),
        /zsh/              => fg(:blue),
        /shell|SHELL/      => fg(:purple),
        /perl/             => fg(:yellow),
        /ruby/             => fg(:red),
        /python/           => fg(:cyan),
        /x86|i386/         => fgb(:blue),
        /broken|NOT FOUND/ => fgb(:red),
        /link|socket/      => fgb(:yellow),
        /directory/        => fgb(:black),
        /program/          => fgb(:yellow),
        /GIF/              => fgb(:purple),
      }
    end

    COLOR_MAP = {
      black:  0,
      red:    1,
      green:  2,
      yellow: 3,
      blue:   4,
      purple: 5,
      cyan:   6,
      white:  7,
    }

    def initialize entry
      @entry = entry
    end

    def color
      colors.detect do |regex, ansi|
        break ansi if regex =~ @entry.type
      end || "\033[0m"
    end

    def fg color_name
      esc 0, "3#{COLOR_MAP[color_name]}"
    end

    def fgb color_name
      esc 1, "3#{COLOR_MAP[color_name]}"
    end

    def esc style, color_code
      "\033[#{style};#{color_code}m"
    end
  end

  class Formatter
    def initialize root
      @root = root
    end

    def render recourse = 0, parent_longest = 0
      render_recourse @root, recourse, parent_longest
    end

    def render_recourse entry, recourse, parent_longest, indent = 0
      if entry.directory? then
        if entry.children.empty? then
          line entry, parent_longest, indent
        else
          line entry, parent_longest, indent
          entry.children.each do |child|
            render_recourse child, (recourse - 1), (entry.longest + 1), (indent + 1)
          end
        end
      else
        line entry, parent_longest, indent
      end
    end

    def line entry, longest, indent
      print Theme.new(entry).color, (' ' * (indent * 2)),
        entry.name.ljust(longest), ?\t, entry.type, ?\n
    end
  end

  class CLI
    def initialize args
      @recourse = args.include?('-r') ? Float::INFINITY : 0
      @paths = args.reject{|a| a == '-r' }
    end

    def recourse?
      @recourse
    end

    def run
      walk @recourse
    end

    def paths
      if @paths.empty?
        @paths = Array(Pathname.pwd)
      else
        @paths
      end
    end

    def walk recourse = 0
      longest = paths.map{|path| path.length }.max

      paths.each do |path|
        Formatter.new(wrap path).render recourse, longest
      end
    end

    def wrap path
      path = Pathname.new path
      if path.directory? then
        Directory.new path
      else
        Entry.new path
      end
    end
  end

end

WhatKind::CLI.new(ARGV).run
